

#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_scalar_block_layout : require


#include "../common/host_device.h"
#include "../common/PBR_functions.glsl"
#include "../common/util.glsl"

// clang-format off
layout(location = 0) rayPayloadEXT hitPayload prd;
layout(location = 1) rayPayloadEXT bool isShadowed;

layout(set = 0, binding = eTlas) uniform accelerationStructureEXT topLevelAS;
layout(set = 0, binding = eOutImage, rgba16f) uniform image2D image;
layout(set = 1, binding = 0) uniform _GlobalUniforms { GlobalUniforms uni; };

layout(set = 1, binding = 5, scalar) buffer LightSources {LightSource lights[MAX_LIGHTS]; };
layout(set = 2, binding = 0, rgba16f) uniform image2D albedo; 
layout(set = 2, binding = 1, rgba16f) uniform image2D normal; 
layout(set = 2, binding = 2, rgba16f) uniform image2D material;
layout(set = 2, binding = 3, rgba32f) uniform image2D emission; 
layout(set = 2, binding = 4, r32f) uniform image2D depth; 
layout(set = 2, binding = 5, rgba32f) uniform image2D colorHistory;
layout(set = 2, binding = 6, r32f) uniform image2D depthHistory;

layout(push_constant) uniform _PushConstantRay { PushConstantRay pcRay; };
// clang-format on

float zNear = 0.1;
float zFar = 1000.0;



vec3 reconstructWorldPosition(
    double rawDepth,        // non‑linear depth sample ∈ [0,1], near→1, far→0
    vec2 fragCoord,        // pixel coords (e.g., gl_FragCoord.xy + 0.5)
    vec2 viewportSize,     // render target dims
    mat4 invProj,          // inverse projection matrix
    mat4 invView           // inverse view (camera) matrix
) {
    // 1) Compute NDC X/Y ∈ [−1,1]
    dvec2 ndc;
    ndc.x = double(fragCoord.x) / double(viewportSize.x) * 2.0 - 1.0;
    ndc.y = double(fragCoord.y) / double(viewportSize.y) * 2.0 - 1.0;
    // (You can flip Y here if your proj already flipped it) 
    // 2) Use rawDepth as NDC Z (Vulkan reversed‑Z, already in [0,1])
    double ndcZ = rawDepth;

    // 3) Form clip‑space position (homogeneous)
    dvec4 clipPos = dvec4(ndc, ndcZ, 1.0);

    // 4) Unproject to view (eye) space
    dvec4 viewPos = invProj * clipPos;
    viewPos /= viewPos.w;

    // 5) Transform into world space
    dvec4 worldPosH = invView * viewPos;
    return vec3(worldPosH.xyz);
}




LightSample sampleLightsPdf(vec3 hitPoint, inout uint seed,  int lightCount) {
    // 1) Pick one light uniformly
    uint i = randRange(seed, 0, lightCount - 1);
    LightSource Ls = lights[i];
    float selectPdf = 1.0 / float(lightCount);  // P(l)

    LightSample s = ProcessLight(hitPoint, seed, Ls); // Sample the light source
    s.pdf *= selectPdf; // Scale the pdf by the light source pdf
    return s;
}

float LinearizeDepth(float depth) {
    // depth ∈ [0,1], where 1.0 → zNear and 0.0 → zFar
    return zNear * zFar / (zFar + depth * (zNear - zFar));
}

bool CheckUv(vec2 uv, vec2 size){
  if(uv.x < 0.0 || uv.x > size.x) return false;
  if(uv.y < 0.0 || uv.y > size.y) return false;
  return true;
}

float eps = 1e-4;

bool CheckAgainstDepth(vec2 uv, vec2 size,float calculatedDepth, image2D oldDepth ){
  bool uvInBounds = CheckUv(uv, size);
  if(!uvInBounds) return false;
  float depth = imageLoad(oldDepth, ivec2(uv)).r;
  if (abs(depth - calculatedDepth) < eps)
    return true;
  return false;
}

vec3 SampleVndf_GGX(vec2 u, vec3 wi, float alpha, vec3 n)
{
    // decompose the vector in parallel and perpendicular components
    vec3 wi_z = n * dot(wi, n);
    vec3 wi_xy = wi - wi_z;
    // warp to the hemisphere configuration
    vec3 wiStd = normalize(wi_z - alpha * wi_xy);
    // sample a spherical cap in (-wiStd.z, 1]
    float wiStd_z = dot(wiStd, n);
    float phi = (2.0f * u.x - 1.0f) * M_PI;
    float z = (1.0f - u.y) * (1.0f + wiStd_z) - wiStd_z;
    float sinTheta = sqrt(clamp(1.0f - z * z, 0.0f, 1.0f));
    float x = sinTheta * cos(phi);
    float y = sinTheta * sin(phi);
    vec3 cStd = vec3(x, y, z);
    // reflect sample to align with normal
    vec3 up = vec3(0, 0, 1);
    vec3 wr = n + up;
    vec3 c = dot(wr, cStd) * wr / wr.z - cStd;
    // compute halfway direction as standard normal
    vec3 wmStd = c + wiStd;
    vec3 wmStd_z = n * dot(n, wmStd);
    vec3 wmStd_xy = wmStd_z - wmStd;
    // warp back to the ellipsoid configuration
    vec3 wm = normalize(wmStd_z + alpha * wmStd_xy);
    // return final normal
    return wm;
}

void main()
{
  const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
  const vec2 inUV        = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
  vec2       d           = inUV * 2.0 - 1.0; 
  vec4 origin    = uni.viewInverse * vec4(0, 0, 0, 1);

  vec4 target    = uni.projInverse * vec4(d.x, d.y, 1, 1);
  vec4 direction = uni.viewInverse * vec4(normalize(target.xyz), 0);

  vec4 currentColor = imageLoad(colorHistory, ivec2(gl_LaunchIDEXT.xy));
  double currentDepth = imageLoad(depth, ivec2(gl_LaunchIDEXT.xy)).r;
  if (currentDepth == 0.0) {
    imageStore(colorHistory, ivec2(gl_LaunchIDEXT.xy), vec4(0.0, 0.0, 0.0, 1.0));
    return; // If there is no depth, then nothing has been rendered here.
  }
  vec3 N =        imageLoad(normal, ivec2(gl_LaunchIDEXT.xy)).xyz;
  vec4 material = imageLoad(material, ivec2(gl_LaunchIDEXT.xy));
  vec4 albedoColor = imageLoad(albedo, ivec2(gl_LaunchIDEXT.xy));
  vec4 emission =        imageLoad(emission, ivec2(gl_LaunchIDEXT.xy));

  vec2 vpSize      = vec2(gl_LaunchSizeEXT.xy);  
  vec3 worldPos = reconstructWorldPosition(
    currentDepth, 
    pixelCenter, 
    vpSize, 
    uni.projInverse, 
    uni.viewInverse);

  // Linearize currentDepth

  // Reproject and get screen space position
  vec4 reprojectedPos = uni.oldViewProj * vec4(worldPos, 1.0);
  vec3 reprojNDC = reprojectedPos.xyz / reprojectedPos.w;      // NDC xyz
  vec2 reprojUV  = reprojNDC.xy * 0.5 + 0.5; 
  vec2 reprojPixel = reprojUV.xy * vec2(gl_LaunchSizeEXT.xy);
  bool reprojectionSuccessFull = false;
  if (CheckUv(vec2(reprojPixel), vec2(gl_LaunchSizeEXT.xy))) {
    float oldRawDepth = imageLoad(depthHistory, ivec2(reprojPixel.xy)).r;    // reversed‐Z
    float reprojDepth  = reprojNDC.z;                           // also reversed‐Z
    // optional: linearize both depths to view‐space
    float linOld  = zNear * zFar / (zFar + oldRawDepth * (zNear - zFar));;
    float linNew  = zNear * zFar / (zFar + reprojDepth * (zNear - zFar));;
    reprojectionSuccessFull = abs(linOld - linNew) > eps;
  }


  // sample old depth and compare




  float roughness = material.r;
  float metalness = material.g;
  prd.seed = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, int(uni.raytracingSettings.seed));;



  direction = -direction;
  vec3 V = normalize(origin.xyz- worldPos);
  LightSample l_Sample = sampleLightsPdf(worldPos, prd.seed, uni.raytracingSettings.lightCount);
  







  int rayDepth = 0;
	prd.depth = 0;
	vec3 tangent, bitangent;
  float e = 1e-3;

  prd.rayOrigin = worldPos;
  prd.rayDir = -direction.xyz;
  prd.normal = N;
  prd.attenuation = vec3(1.0);
  vec3 F0 = mix(vec3(0.04), albedoColor.xyz, metalness);
	vec3 rayOrigin = prd.rayOrigin + V*e;
	vec3 hitNormal = prd.normal;
  createCoordinateSystem(hitNormal, tangent, bitangent);

	vec3 rayDirection = samplingHemisphere(prd.seed, tangent, bitangent, hitNormal);
  vec3 firstDirection = rayDirection;
  vec3 indirectIllumination = vec3(0);
  for (;;){

		float tMin   = e;
		float tMax   = 10000000.0;
		vec3  rayDir = rayDirection;
		uint  flags  = gl_RayFlagsNoneEXT;
		prd.depth += 1;
		prd.rayDir = rayDir;
    prd.hitValue = vec3(0);
		traceRayEXT(topLevelAS,  // acceleration structure
						flags,       // rayFlags
						0xFF,        // cullMask
						0,           // sbtRecordOffset 
						0,           // sbtRecordStride
						0,           // missIndex
						rayOrigin,      // ray origin
						tMin,        // ray min range
						rayDirection,      // ray direction
						tMax,        // ray max range
						0            // payload is payload
		);

  	float cosNL    = max(dot(N, rayDirection), 0.0);
    float hemiPdf  = cosNL / PI;
    float invPdf   = PI / max(cosNL, 1e-6);


    PBR_result result = CalculatePBRResult(
      N,V,
      rayDirection, albedoColor.xyz, 
      prd.hitValue, 1.0f, 
      F0, metalness, 
      roughness);
    


		indirectIllumination += result.color * invPdf;
    if(prd.depth > 0 || prd.done == 1)
      break;
    rayOrigin = prd.rayOrigin + V*e;
    hitNormal = prd.normal;
    createCoordinateSystem(hitNormal, tangent, bitangent);

    rayDirection = samplingHemisphere(prd.seed, tangent, bitangent, hitNormal);
  }

  // Next event estimation for direct lighting
  isShadowed   = true; 
  vec3 directIllumination = vec3(0.0);

  vec3 L = normalize(l_Sample.direction);

    if(dot(N, l_Sample.direction) > 0)
    {
      float tMin   = 0.001;
      float tMax   = l_Sample.distance; 
      vec3  rayOrigin = worldPos;
      vec3  rayDir = L;
      uint  flags  = gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT | gl_RayFlagsSkipClosestHitShaderEXT;
      traceRayEXT(topLevelAS,  // acceleration structure
            flags,       // rayFlags
            0xFF,        // cullMask
            0,           // sbtRecordOffsetw
            0,           // sbtRecordStride
            1,           // missIndex
            rayOrigin,      // ray origin
            tMin,        // ray min range
            rayDir,      // ray direction
            tMax,        // ray max range
            1            // payload is isShadowed
      );

      if (!isShadowed){
        PBR_result res =  CalculatePBRResult(N,V,L,albedoColor.xyz, l_Sample.color, l_Sample.intensity, F0, metalness, roughness);
        directIllumination += (res.color * l_Sample.attenuation) / l_Sample.pdf;

      }
    }

  vec3 combined = indirectIllumination + directIllumination;

  vec3 currentRayCount =  vec3(uni.raytracingSettings.currentRayCount);
  vec3 rayBudget =  vec3(uni.raytracingSettings.rayBudget);
  vec3 invNext = rayBudget / (currentRayCount + rayBudget);

  
  vec3 accumulatedColor = currentColor.rgb
                        + (combined - currentColor.rgb) * invNext;

  vec3 dotp = vec3(dot(N, l_Sample.direction));

  imageStore(colorHistory,
            ivec2(gl_LaunchIDEXT.xy),
            vec4(accumulatedColor, 1.0));

}
