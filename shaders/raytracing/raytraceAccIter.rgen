

#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require


#include "../common/host_device.h"
#include "../common/PBR_functions.glsl"
// clang-format off
layout(location = 0) rayPayloadEXT hitPayload prd;
layout(location = 1) rayPayloadEXT bool isShadowed;

layout(set = 0, binding = eTlas) uniform accelerationStructureEXT topLevelAS;
layout(set = 0, binding = eOutImage, rgba16f) uniform image2D image;
layout(set = 1, binding = eGlobals) uniform _GlobalUniforms { GlobalUniforms uni; };
layout(set = 2, binding = 0, rgba16f) uniform image2D albedo; 
layout(set = 2, binding = 1, rgba16f) uniform image2D normal; 
layout(set = 2, binding = 2, rgba16f) uniform image2D material; 
layout(set = 2, binding = 3, rgba32f) uniform image2D emission; 
layout(set = 2, binding = 4, r32f) uniform image2D depth;

layout(push_constant) uniform _PushConstantRay { PushConstantRay pcRay; };
// clang-format on
uint tea(uint val0, uint val1)
{
  uint v0 = val0;
  uint v1 = val1;
  uint s0 = 0;

  for(uint n = 0; n < 16; n++)
  {
    s0 += 0x9e3779b9;
    v0 += ((v1 << 4) + 0xa341316c) ^ (v1 + s0) ^ ((v1 >> 5) + 0xc8013ea4);
    v1 += ((v0 << 4) + 0xad90777d) ^ (v0 + s0) ^ ((v0 >> 5) + 0x7e95761e);
  }

  return v0;
}

float near = 0.001;
float far = 1000.0;
float LinearizeDepth(float depth)
{
  float ProjectionA = far / (far - near);
  float ProjectionB = (-far * near) / (far - near);

    // Assumes 'depth' is in [0,1] (Vulkan style)
    return ProjectionB / (depth - ProjectionA);
}

vec3 ReconstructWorldPosition(vec2 uv, float depth, mat4 invProj, mat4 invView)
{
    // Convert the uv coordinates from [0, 1] to normalized device coordinates [-1, 1].
    vec2 ndcXY = uv * 2.0 - 1.0;
    // Convert the depth value from [0, 1] (Vulkan style) to clip-space z [-1, 1].
    float clipZ = depth * 2.0 - 1.0;
    
    // Build the clip-space position (homogeneous coordinates).
    vec4 clipPos = vec4(ndcXY, clipZ, 1.0);
    
    // Transform the clip-space position into view space using the inverse projection matrix.
    vec4 viewPos = invProj * clipPos;
    // Do the perspective divide to get normalized view-space coordinates.
    viewPos /= viewPos.w;
    
    // Now transform the view-space position into world space using the inverse view matrix.
    vec4 worldPos = invView * viewPos;
    
    return worldPos.xyz;
}




// Generate a random unsigned int in [0, 2^24) given the previous RNG state
// using the Numerical Recipes linear congruential generator
uint lcg(inout uint prev)
{
  uint LCG_A = 1664525u;
  uint LCG_C = 1013904223u;
  prev       = (LCG_A * prev + LCG_C);
  return prev & 0x00FFFFFF;
}

// Generate a random float in [0, 1) given the previous RNG state
float rnd(inout uint prev)
{
  return (float(lcg(prev)) / float(0x01000000));
}


//-------------------------------------------------------------------------------------------------
// Sampling
//-------------------------------------------------------------------------------------------------

// Randomly samples from a cosine-weighted hemisphere oriented in the `z` direction.
// From Ray Tracing Gems section 16.6.1, "Cosine-Weighted Hemisphere Oriented to the Z-Axis"
vec3 samplingHemisphere(inout uint seed, in vec3 x, in vec3 y, in vec3 z)
{
#define M_PI 3.14159265

  float r1 = rnd(seed);
  float r2 = rnd(seed);
  float sq = sqrt(r1);

  vec3 direction = vec3(cos(2 * M_PI * r2) * sq, sin(2 * M_PI * r2) * sq, sqrt(1. - r1));
  direction      = direction.x * x + direction.y * y + direction.z * z;

  return direction;
}

void createCoordinateSystem(in vec3 N, out vec3 Nt, out vec3 Nb)
{
  if(abs(N.x) > abs(N.y))
    Nt = vec3(N.z, 0, -N.x) / sqrt(N.x * N.x + N.z * N.z);
  else
    Nt = vec3(0, -N.z, N.y) / sqrt(N.y * N.y + N.z * N.z);
  Nb = cross(N, Nt);
}

void main()
{
  const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
  const vec2 inUV        = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
  vec2       d           = inUV * 2.0 - 1.0;
  vec4 origin    = uni.viewInverse * vec4(0, 0, 0, 1);

  vec4 target    = uni.projInverse * vec4(d.x, d.y, 1, 1);
  vec4 direction = uni.viewInverse * vec4(normalize(target.xyz), 0);

  vec4 currentColor = SRGBtoLINEAR(imageLoad(image, ivec2(gl_LaunchIDEXT.xy)));
  vec4 currentAlbedo = SRGBtoLINEAR(imageLoad(material, ivec2(gl_LaunchIDEXT.xy)));
  // float currentDepth = imageLoad(depth, ivec2(gl_LaunchIDEXT.xy)).r;
  // currentDepth = LinearizeDepth(currentDepth);

  // vec3 z = normalize(uni.viewInverse * vec4(0,0,-1,0)).xyz;

  // float viewZDist = dot(z, normalize(direction.xyz));

  // vec3 worldPos = origin.xyz + direction.xyz * far* (currentDepth / viewZDist);

  vec3 N =        imageLoad(normal, ivec2(gl_LaunchIDEXT.xy)).xyz;
  vec4 material = imageLoad(material, ivec2(gl_LaunchIDEXT.xy));
  vec4 albedoColor = imageLoad(albedo, ivec2(gl_LaunchIDEXT.xy));
  vec4 emission =        imageLoad(emission, ivec2(gl_LaunchIDEXT.xy));
  vec3 worldPos = emission.xyz;



  float roughness = material.r;
  float metalness = material.g;



  direction = -direction;
  vec3 V = normalize(origin.xyz- worldPos);
  vec3  L;
	float lightIntensity = pcRay.lightIntensity;
	float lightDistance  = 100000.0;
	// Point light
	if(pcRay.lightType == 0)
	{
		vec3 lDir      = pcRay.lightPosition - worldPos;
		lightDistance  = length(lDir);
		lightIntensity = pcRay.lightIntensity / (lightDistance * lightDistance);
		L              = normalize(lDir);
	} 
	else  // Directional light
	{
		L = -normalize(pcRay.lightPosition);
	}

  int rayDepth = 0;
	prd.depth = 0;
	vec3 tangent, bitangent;

  prd.rayOrigin = worldPos;
  prd.rayDir = -direction.xyz;
  prd.normal = N;
  vec3 outColor = vec3(0);
  for (;;){
		vec3  origin = prd.rayOrigin;
		vec3 hitNormal = prd.normal;
    createCoordinateSystem(hitNormal, tangent, bitangent);

		vec3 rayDirection = samplingHemisphere(prd.seed, tangent, bitangent, hitNormal);
		float tMin   = 0.001;
		float tMax   = 10000000.0;
		vec3  rayDir = rayDirection;
		uint  flags  = gl_RayFlagsNoneEXT;
		prd.depth += 1;
		prd.rayOrigin;
		prd.rayDir = rayDir;
		traceRayEXT(topLevelAS,  // acceleration structure
						flags,       // rayFlags
						0xFF,        // cullMask
						0,           // sbtRecordOffset
						0,           // sbtRecordStride
						0,           // missIndex
						origin,      // ray origin
						tMin,        // ray min range
						rayDir,      // ray direction
						tMax,        // ray max range
						0            // payload is payload
		);
		vec3 lCol = prd.hitValue;
			
		outColor += lCol;
    if(prd.depth > 2)
      break;
  }


      isShadowed   = true; 


    if(dot(N, L) > 0)
    {

      float tMin   = 0.1;
      float tMax   = lightDistance;
      vec3  rayOrigin = worldPos + L * 0.001;
      vec3  rayDir = L;
      uint  flags  = gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT | gl_RayFlagsSkipClosestHitShaderEXT;
      traceRayEXT(topLevelAS,  // acceleration structure
            flags,       // rayFlags
            0xFF,        // cullMask
            0,           // sbtRecordOffset
            0,           // sbtRecordStride
            1,           // missIndex
            rayOrigin,      // ray origin
            tMin,        // ray min range
            rayDir,      // ray direction
            tMax,        // ray max range
            1            // payload is isShadowed
      );
    }

    vec3 H = normalize(L + V);
    vec3 lightColor = pcRay.lightColor * lightIntensity;
    vec3 color = vec3(0);
    vec3 F0 = mix(vec3(0.04), albedoColor.xyz, metalness);
    if (!isShadowed){
      // outColor += CalculatePBR(N,V,L,albedoColor.xyz,lightColor, lightIntensity, F0, metalness, roughness);
    }

  


  // imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(emission.xyz, 1.0));
  vec3 gammaCorrectedColor = LINEARtoSRGB(outColor);
  
  imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(gammaCorrectedColor.xyz, 1.0));

  // dvec3 finalColor = dvec3(0);
  // vec4 origin    = uni.viewInverse * vec4(0, 0, 0, 1);
  // vec4 target    = uni.projInverse * vec4(d.x, d.y, 1, 1);
  // vec4 direction = uni.viewInverse * vec4(normalize(target.xyz), 0);
  // uint  rayFlags = gl_RayFlagsOpaqueEXT;
  // float tMin     = 0.001;
  // float tMax     = 10000.0;
  // prd.depth       = 0;
  // prd.hitValue    = vec3(0);
  // prd.attenuation = vec3(1.f, 1.f, 1.f);
  // prd.done        = 1;
  // prd.rayOrigin   = origin.xyz;
  // prd.rayDir      = direction.xyz;
  // prd.currentIoR  = 1.0;
  // prd.rayBudget = uni.raytracingSettings.rayBudget;
  // prd.seed = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, int(uni.raytracingSettings.seed));;

  
  // traceRayEXT(topLevelAS,     // acceleration structure
  //             rayFlags,       // rayFlags
  //             0xFF,           // cullMask
  //             0,              // sbtRecordOffset
  //             0,              // sbtRecordStride
  //             0,              // missIndex
  //             origin.xyz,     // ray origin
  //             tMin,           // ray min range
  //             direction.xyz,  // ray direction
  //             tMax,           // ray max range
  //             0               // payload (location = 0)
  // );

  // vec3 currentRayCount =  vec3(uni.raytracingSettings.currentRayCount);
  // vec3 rayBudget =  vec3(uni.raytracingSettings.rayBudget);
  // vec3 accumelatedColor = 
  //   ((currentColor.rgb * currentRayCount) 
  //   + (prd.hitValue.rgb * rayBudget))
  //   / (currentRayCount + rayBudget);

  // vec3 gammaCorrectedColor = LINEARtoSRGB(accumelatedColor);
  

  // imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(prd.hitValue.rgb, 1.0));
}
