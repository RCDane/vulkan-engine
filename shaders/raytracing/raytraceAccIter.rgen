#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
// #extension GL_EXT_nonuniform_qualifier : require  
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_ARB_shader_clock : enable
#extension GL_EXT_buffer_reference2 : require
#include "../common/host_device.h"
#include "../common/PBR_functions.glsl"
#include "../common/util.glsl" 

// clang-format off
layout(location = 0) rayPayloadEXT hitPayload prd;
layout(location = 1) rayPayloadEXT bool isShadowed;

layout(set = 0, binding = eTlas) uniform accelerationStructureEXT topLevelAS;
layout(set = 0, binding = eOutImage, rgba16f) uniform image2D image;
layout(set = 1, binding = 0) uniform _GlobalUniforms { GlobalUniforms uni; };

layout(set = 2, binding = 0, rgba16f) readonly uniform image2D albedo; 
layout(set = 2, binding = 1, rgba16f) readonly uniform image2D normal; 
layout(set = 2, binding = 2, r11f_g11f_b10f) readonly uniform image2D material;
layout(set = 2, binding = 3, rgba32f) readonly uniform image2D emission; 
layout(set = 2, binding = 4, r32f) readonly uniform image2D depth; 
layout(set = 2, binding = 5, rgba32f) uniform image2D colorHistory; 
layout(set = 3, binding = 0, std430) readonly buffer LightSources {LightSource l[]; } lights; 

layout(push_constant) uniform _PushConstantRay { PushConstantRay pcRay; };







LightSample sampleLightsPdf(vec3 hitPoint, inout uint seed,  int lightCount) { 
    // 1) Pick one light uniformly 
    uint i = randRange(seed, 0, lightCount - 1);

    LightSource Ls = lights.l[i];

    LightSample s = ProcessLight(hitPoint, seed, Ls); // Sample the light source
    s.pdf /= lightCount ; // Scale the pdf by the light source pdf 
    return s; 
}



bool CheckUv(vec2 uv, vec2 size){
  if(uv.x < 0.0 || uv.x > size.x) return false;
  if(uv.y < 0.0 || uv.y > size.y) return false;
  return true;
}

float eps = 1e-4;

bool CheckAgainstDepth(vec2 uv, vec2 size,float calculatedDepth, image2D oldDepth ){
  bool uvInBounds = CheckUv(uv, size);
  if(!uvInBounds) return false;
  float depth = imageLoad(oldDepth, ivec2(uv)).r;
  if (abs(depth - calculatedDepth) < eps)
    return true;
  return false;
}

vec3 sampleGGXDirection(
    in vec3 N,
    in vec3 V,
    in float roughness,
    in vec3 T,
    in vec3 B,
    inout uint seed,
    out float pdf_out
) {

    float a = roughness * roughness;
    float u1 = rnd(seed), u2 = rnd(seed);

    float phi  = 2.0 * PI * u1;
    float cos0 = sqrt( (1.0 - u2) / (1.0 + (a*a - 1.0) * u2) );
    float sin0 = sqrt(max(0.0, 1.0 - cos0*cos0)); 

    vec3 Ht = vec3(cos(phi)*sin0, sin(phi)*sin0, cos0);
    vec3 H  = normalize(T * Ht.x + B * Ht.y + N * Ht.z);

    vec3 L = reflect(-V, H);


    float D     = DistributionGGX(N, H, roughness);
    float NdotH = max(dot(N, H), 0.0);
    float VdotH = max(dot(V, H), 1e-7); // avoid zero
    pdf_out = (D * NdotH) / (4.0 * VdotH); 

    return L;
}


float G1_GGX(float NdotV, float roughness)
{
    if (NdotV <= 0.0) return 0.0;
    float a2 = roughness * roughness;
    float NdotV2 = NdotV * NdotV;
    if (NdotV2 > 0.9999) return 1.0;
    float tan2_theta = (1.0 - NdotV2) / NdotV2;

    return 2.0 / (1.0 + sqrt(1.0 + a2 * tan2_theta));
}

// Calculates the PDF for a sample generated by sampleGGXVNDF
float pdfGGXVNDF(vec3 N, vec3 V, vec3 H, float roughness)
{
    float NdotV = max(dot(N, V), 0.0001); // Clamp to avoid division by zero
    float D = DistributionGGX(N, H, roughness);
    float G1 = G1_GGX(NdotV, roughness);
    
    return (G1 * D) / (4.0 * NdotV);
}
vec3 sampleGGXVNDF(vec3 Ve, float alpha, float U1, float U2, out float pdf)
{
// Section 3.2: transforming the view direction to the hemisphere configuration
vec3 Vh = normalize(vec3(alpha * Ve.x, alpha * Ve.y, Ve.z));
// Section 4.1: orthonormal basis (with special case if cross product is zero)
float lensq = Vh.x * Vh.x + Vh.y * Vh.y;
vec3 T1 = lensq > 0 ? vec3(-Vh.y, Vh.x, 0) * inversesqrt(lensq) : vec3(1,0,0);
vec3 T2 = cross(Vh, T1);
// Section 4.2: parameterization of the projected area
float r = sqrt(U1);
float phi = 2.0 * M_PI * U2;
float t1 = r * cos(phi);
float t2 = r * sin(phi);
float s = 0.5 * (1.0 + Vh.z);
t2 = (1.0 - s)*sqrt(1.0 - t1*t1) + s*t2;
// Section 4.3: reprojection onto hemisphere
vec3 Nh = t1*T1 + t2*T2 + sqrt(max(0.0, 1.0 - t1*t1 - t2*t2))*Vh;
// Section 3.4: transforming the normal back to the ellipsoid configuration
vec3 Ne = normalize(vec3(alpha * Nh.x, alpha * Nh.y, max(0.0, Nh.z)));

pdf = pdfGGXVNDF(vec3(0.0, 0.0, 1.0), Ve, Ne, alpha);

return Ne;
}





void main()
{
  
  const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
  const vec2 inUV        = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
  vec2       d           = inUV * 2.0 - 1.0; 
  vec4 origin    = uni.viewInverse * vec4(0, 0, 0, 1);   

  vec4 target    = uni.projInverse * vec4(d.x, d.y, 1, 1);
  vec4 direction = uni.viewInverse * vec4(normalize(target.xyz), 0);

  double currentDepth = imageLoad(depth, ivec2(gl_LaunchIDEXT.xy)).r;
  if (currentDepth == 0.0) {
    imageStore(colorHistory, ivec2(gl_LaunchIDEXT.xy), vec4(0.0, 0.0, 0.0, 1.0));
    return; // If there is no depth, then nothing has been rendered here.
  }
  vec3 N =        oct_to_ndir_unorm(imageLoad(normal, ivec2(gl_LaunchIDEXT.xy)).xy);
  vec4 material = imageLoad(material, ivec2(gl_LaunchIDEXT.xy));
  vec4 albedoColor = imageLoad(albedo, ivec2(gl_LaunchIDEXT.xy));
  vec4 emission =        imageLoad(emission, ivec2(gl_LaunchIDEXT.xy));

  vec2 vpSize      = vec2(gl_LaunchSizeEXT.xy);  
  dvec3 worldPos = reconstructWorldPosition(
    currentDepth, 
    pixelCenter, 
    vpSize, 
    uni.projInverse, 
    uni.viewInverse);

 

  float roughness = material.r;
  float metalness = material.g;
  prd.seed = tea(gl_LaunchIDEXT.x* gl_LaunchIDEXT.y +gl_LaunchIDEXT.x , gl_LaunchIDEXT.x* gl_LaunchIDEXT.y *uint(clockARB()));
  uint seed = tea(gl_LaunchIDEXT.x* gl_LaunchIDEXT.y +gl_LaunchIDEXT.x , uint(clockARB()));


  vec3 V = normalize(origin.xyz- vec3(worldPos));


  int rayDepth = 0;
	prd.depth = 0;
	vec3 tangent, bitangent; 
  float e = 1e-2;

  vec3 rayOrigin = vec3(worldPos);
	vec3 hitNormal = N;
  createCoordinateSystem(hitNormal, tangent, bitangent);




  vec3 indirectIllumination = vec3(0);  

  float pdf = 0.0;
  // Importance sample GGX for indirect illumination
  for (int i = 0; i < pcRay.indirectLightSamples; ++i) {

    vec3 V_local = vec3(dot(V, tangent), dot(V, bitangent), dot(V, hitNormal));
    float alpha = roughness * roughness;

    vec3 H_local = sampleGGXVNDF(
      V_local,
      alpha,
      rnd(seed),
      rnd(seed),
      pdf
    );
    // Transform H back to world space
    vec3 H_world = normalize(tangent * H_local.x + bitangent * H_local.y + hitNormal * H_local.z);
    
    // Calculate the reflection direction L from V and H
    vec3 rayDirection = reflect(-V, H_world);


    float tMin   = e;
    float tMax   = 10000000.0;
    vec3  rayDir = rayDirection;
    uint  flags  = gl_RayFlagsNoneEXT;
    prd.rayDir = rayDirection;
    prd.hitValue = vec3(0);
    prd.attenuation = vec3(1.0);
    prd.rayOrigin = vec3(worldPos);
    traceRayEXT(topLevelAS,  // acceleration structure
      flags,       // rayFlags
      0xFF,        // cullMask 
      0,           // sbtRecordOffset 
      0,           // sbtRecordStride
      0,           // missIndex 
      rayOrigin,      // ray origin
      tMin,        // ray min range
      rayDirection,      // ray direction
      tMax,        // ray max range
      0            // payload is payload
    );
    if (pdf > 0.0) {
        // Calculate Fresnel term
        vec3 F0 = mix(vec3(0.04), albedoColor.rgb, metalness);
        vec3 F = fresnelSchlick(max(dot(H_world, V), 0.0), F0);

        // Calculate Smith G1 term for the light direction
        float NdotL = max(dot(hitNormal, rayDirection), 0.0);
        float G1_L = G1_GGX(NdotL, roughness);

        // The simplified contribution from the bounced ray
        vec3 specular_contribution = F * G1_L * prd.hitValue;
        indirectIllumination += specular_contribution;
    }
  }
  indirectIllumination /= float(pcRay.indirectLightSamples);

  prd.rayOrigin = vec3(worldPos);
  prd.rayDir = -direction.xyz;
  prd.normal = N;
  prd.attenuation = vec3(1.0);




  // Next event estimation for direct lighting
  vec3 directIllumination = vec3(0.0);

  for (int i = 0; i < pcRay.directionalLightSamples; i++){

    LightSample Ls = sampleLightsPdf(vec3(worldPos), seed, uni.raytracingSettings.lightCount);


    vec3 L = normalize(Ls.direction);
    isShadowed   = true;
    prd.attenuation = vec3(1.0);
      if(dot(N, L) > 0) 
      {
        
        float tMin   = 0.01;
        float tMax   = Ls.distance; 
        vec3 rayOrigin = vec3(worldPos); // offset the ray origin to avoid self-intersection
        vec3 rayDir = L; 
        uint flags  = gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT | gl_RayFlagsSkipClosestHitShaderEXT;
        traceRayEXT(topLevelAS,  // acceleration structure
              flags,       // rayFlags
              0xFF,        // cullMask
              0,           // sbtRecordOffsetw 
              0,           // sbtRecordStride
              1,           // missIndex 
              rayOrigin,      // ray origin
              tMin,        // ray min range
              Ls.direction,      // ray direction
              tMax,        // ray max range
              1            // payload is isShadowed
        );
  
        
      }
      if (!isShadowed) { 
          PBR_result res =  CalculatePBRResult(N,V,L,albedoColor.xyz, Ls.color, float(Ls.intensity), metalness, roughness);
          directIllumination += ((res.color * Ls.attenuation)) / Ls.pdf ; // divide by the pdf of the light sample

      }   
  }
  
  vec3 combined =indirectIllumination; // combine direct and indirect illumination
  combined += directIllumination / pcRay.directionalLightSamples ;
  float currentRayCount =  float(uni.raytracingSettings.currentRayCount);
  float rayBudget =  float(uni.raytracingSettings.rayBudget); 
  float invNext = rayBudget / (currentRayCount + rayBudget);  

 
  vec3 currentColor = imageLoad(colorHistory, ivec2(gl_LaunchIDEXT.xy)).rgb; 


  vec3 accumulatedColor = currentColor.rgb 
                        + (combined - currentColor.rgb) * invNext;



  vec3 outColor = combined;
  if (pcRay.useAccumulation == 1) {
    outColor = accumulatedColor;
  }

  // More sophisticated approach - lower clamping threshold for glossy surfaces
  float maxValue = mix(1.0, 10.0, roughness); // Lower for glossy, higher for rough
  indirectIllumination = min(indirectIllumination, vec3(maxValue));

  imageStore(colorHistory,
            ivec2(gl_LaunchIDEXT.xy),
            vec4(outColor,1.0)); // store the color in the history buffer

}
