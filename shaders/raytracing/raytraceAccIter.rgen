

#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require


#include "../common/host_device.h"
#include "../common/PBR_functions.glsl"
#include "../common/util.glsl"

// clang-format off
layout(location = 0) rayPayloadEXT hitPayload prd;
layout(location = 1) rayPayloadEXT bool isShadowed;

layout(set = 0, binding = eTlas) uniform accelerationStructureEXT topLevelAS;
layout(set = 0, binding = eOutImage, rgba16f) uniform image2D image;
layout(set = 1, binding = eGlobals) uniform _GlobalUniforms { GlobalUniforms uni; };
layout(set = 2, binding = 0, rgba16f) uniform image2D albedo; 
layout(set = 2, binding = 1, rgba16f) uniform image2D normal; 
layout(set = 2, binding = 2, rgba16f) uniform image2D material; 
layout(set = 2, binding = 3, rgba32f) uniform image2D emission; 
layout(set = 2, binding = 4, r32f) uniform image2D depth;

layout(push_constant) uniform _PushConstantRay { PushConstantRay pcRay; };
// clang-format on

float near = 0.001;
float far = 1000.0;
float LinearizeDepth(float depth)
{
  float ProjectionA = far / (far - near);
  float ProjectionB = (-far * near) / (far - near);

    // Assumes 'depth' is in [0,1] (Vulkan style)
    return ProjectionB / (depth - ProjectionA);
}

vec3 ReconstructWorldPosition(vec2 uv, float depth, mat4 invProj, mat4 invView)
{
    // Convert the uv coordinates from [0, 1] to normalized device coordinates [-1, 1].
    vec2 ndcXY = uv * 2.0 - 1.0;
    // Convert the depth value from [0, 1] (Vulkan style) to clip-space z [-1, 1].
    float clipZ = depth * 2.0 - 1.0;
    
    // Build the clip-space position (homogeneous coordinates).
    vec4 clipPos = vec4(ndcXY, clipZ, 1.0);
    
    // Transform the clip-space position into view space using the inverse projection matrix.
    vec4 viewPos = invProj * clipPos;
    // Do the perspective divide to get normalized view-space coordinates.
    viewPos /= viewPos.w;
    
    // Now transform the view-space position into world space using the inverse view matrix.
    vec4 worldPos = invView * viewPos;
    
    return worldPos.xyz;
}


void main()
{
  const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
  const vec2 inUV        = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
  vec2       d           = inUV * 2.0 - 1.0;
  vec4 origin    = uni.viewInverse * vec4(0, 0, 0, 1);

  vec4 target    = uni.projInverse * vec4(d.x, d.y, 1, 1);
  vec4 direction = uni.viewInverse * vec4(normalize(target.xyz), 0);

  vec4 currentColor = SRGBtoLINEAR(imageLoad(image, ivec2(gl_LaunchIDEXT.xy)));
  vec4 currentAlbedo = SRGBtoLINEAR(imageLoad(material, ivec2(gl_LaunchIDEXT.xy)));
  // float currentDepth = imageLoad(depth, ivec2(gl_LaunchIDEXT.xy)).r;
  // currentDepth = LinearizeDepth(currentDepth);

  // vec3 z = normalize(uni.viewInverse * vec4(0,0,-1,0)).xyz;

  // float viewZDist = dot(z, normalize(direction.xyz));

  // vec3 worldPos = origin.xyz + direction.xyz * far* (currentDepth / viewZDist);

  vec3 N =        imageLoad(normal, ivec2(gl_LaunchIDEXT.xy)).xyz;
  vec4 material = imageLoad(material, ivec2(gl_LaunchIDEXT.xy));
  vec4 albedoColor = imageLoad(albedo, ivec2(gl_LaunchIDEXT.xy));
  vec4 emission =        imageLoad(emission, ivec2(gl_LaunchIDEXT.xy));
  vec3 worldPos = emission.xyz;



  float roughness = material.r;
  float metalness = material.g;
  prd.seed = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, int(uni.raytracingSettings.seed));;



  direction = -direction;
  vec3 V = normalize(origin.xyz- worldPos);
  vec3  L;
	float lightIntensity = pcRay.lightIntensity;
	float lightDistance  = 100000.0;
	// Point light
	if(pcRay.lightType == 0)
	{
		vec3 lDir      = pcRay.lightPosition - worldPos;
		lightDistance  = length(lDir);
		lightIntensity = pcRay.lightIntensity / (lightDistance * lightDistance);
		L              = normalize(lDir);
	} 
	else  // Directional light
	{
		L = -normalize(pcRay.lightPosition);
	}

  int rayDepth = 0;
	prd.depth = 0;
	vec3 tangent, bitangent;

  prd.rayOrigin = worldPos;
  prd.rayDir = -direction.xyz;
  prd.normal = N;
  vec3 F0 = mix(vec3(0.04), albedoColor.xyz, metalness);

  vec3 outColor = vec3(0);
  for (;;){
		vec3  origin = prd.rayOrigin;
		vec3 hitNormal = prd.normal;
    createCoordinateSystem(hitNormal, tangent, bitangent);

		vec3 rayDirection = samplingHemisphere(prd.seed, tangent, bitangent, hitNormal);
		float tMin   = 0.001;
		float tMax   = 10000000.0;
		vec3  rayDir = rayDirection;
		uint  flags  = gl_RayFlagsNoneEXT;
    prd.done = 0;
		prd.depth += 1;
		prd.rayDir = rayDir;
    prd.rayOrigin = origin + rayDir * tMin;
    prd.hitValue = vec3(0);
		traceRayEXT(topLevelAS,  // acceleration structure
						flags,       // rayFlags
						0xFF,        // cullMask
						0,           // sbtRecordOffset
						0,           // sbtRecordStride
						0,           // missIndex
						origin,      // ray origin
						tMin,        // ray min range
						rayDirection,      // ray direction
						tMax,        // ray max range
						0            // payload is payload
		);
		vec3 lCol = prd.hitValue;
		
		outColor += CalculatePBR(N,V,rayDir,albedoColor.xyz,lCol, lightIntensity, F0, metalness, roughness);
    if(prd.depth >= 1 || prd.done == 1)
      break;
  }


  isShadowed   = true; 


    if(dot(N, L) > 0)
    {

      float tMin   = 0.0001;
      float tMax   = lightDistance;
      vec3  rayOrigin = worldPos;
      vec3  rayDir = L;
      uint  flags  = gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT | gl_RayFlagsSkipClosestHitShaderEXT;
      traceRayEXT(topLevelAS,  // acceleration structure
            flags,       // rayFlags
            0xFF,        // cullMask
            0,           // sbtRecordOffset
            0,           // sbtRecordStride
            1,           // missIndex
            rayOrigin,      // ray origin
            tMin,        // ray min range
            rayDir,      // ray direction
            tMax,        // ray max range
            1            // payload is isShadowed
      );
      vec3 H = normalize(L + V);
      vec3 lightColor = pcRay.lightColor * lightIntensity;
      vec3 color = vec3(0);
      if (!isShadowed){
        outColor += CalculatePBR(N,V,L,albedoColor.xyz,lightColor, lightIntensity, F0, metalness, roughness);
      }
    }



  vec3 currentRayCount =  vec3(uni.raytracingSettings.currentRayCount);
  vec3 rayBudget =  vec3(uni.raytracingSettings.rayBudget);
  vec3 accumelatedColor = 
    ((currentColor.rgb * currentRayCount) 
    + (outColor * rayBudget))
    / (currentRayCount + rayBudget);

  vec3 gammaCorrectedColor = LINEARtoSRGB(accumelatedColor);
  

  imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(gammaCorrectedColor, 1.0));
}
