

#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require


#include "../common/host_device.h"
#include "../common/PBR_functions.glsl"
#include "../common/util.glsl"

// clang-format off
layout(location = 0) rayPayloadEXT hitPayload prd;
layout(location = 1) rayPayloadEXT bool isShadowed;

layout(set = 0, binding = eTlas) uniform accelerationStructureEXT topLevelAS;
layout(set = 0, binding = eOutImage, rgba16f) uniform image2D image;
layout(set = 1, binding = eGlobals) uniform _GlobalUniforms { GlobalUniforms uni; };
layout(set = 2, binding = 0, rgba16f) uniform image2D albedo; 
layout(set = 2, binding = 1, rgba16f) uniform image2D normal; 
layout(set = 2, binding = 2, rgba16f) uniform image2D material; 
layout(set = 2, binding = 3, rgba32f) uniform image2D emission; 
layout(set = 2, binding = 4, r32f) uniform image2D depth;

layout(push_constant) uniform _PushConstantRay { PushConstantRay pcRay; };
// clang-format on

float zNear = 0.1;
float zFar = 1000.0;

float LinearizeDepth(float depth) {
    // depth ∈ [0,1], where 1.0 → zNear and 0.0 → zFar
    return zNear * zFar / (zFar + depth * (zNear - zFar));
}

vec3 reconstructWorldPosition(
    float rawDepth,        // non‑linear depth sample ∈ [0,1], near→1, far→0
    vec2 fragCoord,        // pixel coords (e.g., gl_FragCoord.xy + 0.5)
    vec2 viewportSize,     // render target dims
    mat4 invProj,          // inverse projection matrix
    mat4 invView           // inverse view (camera) matrix
) {
    // 1) Compute NDC X/Y ∈ [−1,1]
    vec2 ndc;
    ndc.x = fragCoord.x / viewportSize.x * 2.0 - 1.0;
    ndc.y = fragCoord.y / viewportSize.y * 2.0 - 1.0;
    // (You can flip Y here if your proj already flipped it) 
    // 2) Use rawDepth as NDC Z (Vulkan reversed‑Z, already in [0,1])
    float ndcZ = rawDepth;

    // 3) Form clip‑space position (homogeneous)
    vec4 clipPos = vec4(ndc, ndcZ, 1.0);

    // 4) Unproject to view (eye) space
    vec4 viewPos = invProj * clipPos;
    viewPos /= viewPos.w;

    // 5) Transform into world space
    vec4 worldPosH = invView * viewPos;
    return worldPosH.xyz;
}


void main()
{
  const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
  const vec2 inUV        = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
  vec2       d           = inUV * 2.0 - 1.0;
  vec4 origin    = uni.viewInverse * vec4(0, 0, 0, 1);

  vec4 target    = uni.projInverse * vec4(d.x, d.y, 1, 1);
  vec4 direction = uni.viewInverse * vec4(normalize(target.xyz), 0);

  vec4 currentColor = SRGBtoLINEAR(imageLoad(image, ivec2(gl_LaunchIDEXT.xy)));
  float currentDepth = imageLoad(depth, ivec2(gl_LaunchIDEXT.xy)).r;


  vec3 N =        imageLoad(normal, ivec2(gl_LaunchIDEXT.xy)).xyz;
  vec4 material = imageLoad(material, ivec2(gl_LaunchIDEXT.xy));
  vec4 albedoColor = SRGBtoLINEAR(imageLoad(albedo, ivec2(gl_LaunchIDEXT.xy)));
  vec4 emission =        imageLoad(emission, ivec2(gl_LaunchIDEXT.xy));

  vec2 vpSize      = vec2(gl_LaunchSizeEXT.xy);  
  vec3 worldPos = reconstructWorldPosition(
    currentDepth, 
    pixelCenter, 
    vpSize, 
    uni.projInverse, 
    uni.viewInverse);



  float roughness = material.r;
  float metalness = material.g;
  prd.seed = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, int(uni.raytracingSettings.seed));;



  direction = -direction;
  vec3 V = normalize(origin.xyz- worldPos);
  vec3  L;
	float lightIntensity = pcRay.lightIntensity;
	float lightDistance  = 100000.0;
	// Point light
	if(pcRay.lightType == 0)
	{
		vec3 lDir      = pcRay.lightPosition - worldPos;
		lightDistance  = length(lDir);
		lightIntensity = pcRay.lightIntensity / (lightDistance * lightDistance);
		L              = normalize(lDir);
	} 
	else  // Directional light
	{
		L = -normalize(pcRay.lightPosition);
	}

  int rayDepth = 0;
	prd.depth = 0;
	vec3 tangent, bitangent;

  prd.rayOrigin = worldPos;
  prd.rayDir = -direction.xyz;
  prd.normal = N;
  prd.attenuation = vec3(1.0);
  vec3 F0 = mix(vec3(0.04), albedoColor.xyz, metalness);

  vec3 indirectIllumination = vec3(0);
  for (;;){
		vec3  origin = prd.rayOrigin;
		vec3 hitNormal = prd.normal;
    createCoordinateSystem(hitNormal, tangent, bitangent);

		vec3 rayDirection = samplingHemisphere(prd.seed, tangent, bitangent, hitNormal);
		float tMin   = 0.1;
		float tMax   = 10000000.0;
		vec3  rayDir = rayDirection;
		uint  flags  = gl_RayFlagsNoneEXT;
    prd.done = 0;
		prd.depth += 1;
		prd.rayDir = rayDir;
    
    prd.rayOrigin = origin;
    prd.hitValue = vec3(0);
		traceRayEXT(topLevelAS,  // acceleration structure
						flags,       // rayFlags
						0xFF,        // cullMask
						0,           // sbtRecordOffset
						0,           // sbtRecordStride
						0,           // missIndex
						origin,      // ray origin
						tMin,        // ray min range
						rayDirection,      // ray direction
						tMax,        // ray max range
						0            // payload is payload
		);
		indirectIllumination += prd.attenuation * prd.hitValue;
    if(prd.depth > 2 || prd.done == 1)
      break;
  }


  isShadowed   = true; 

  vec3 directIllumination = vec3(0);
    if(dot(N, L) > 0)
    {

      float tMin   = 0.01;
      float tMax   = lightDistance;
      vec3  rayOrigin = worldPos;
      vec3  rayDir = L;
      uint  flags  = gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT | gl_RayFlagsSkipClosestHitShaderEXT;
      traceRayEXT(topLevelAS,  // acceleration structure
            flags,       // rayFlags
            0xFF,        // cullMask
            0,           // sbtRecordOffsetw
            0,           // sbtRecordStride
            1,           // missIndex
            rayOrigin,      // ray origin
            tMin,        // ray min range
            rayDir,      // ray direction
            tMax,        // ray max range
            1            // payload is isShadowed
      );
      vec3 H = normalize(L + V);
      vec3 lightColor = pcRay.lightColor * lightIntensity;
      if (!isShadowed){
        PBR_result res =  CalculatePBRResult(N,V,L,albedoColor.xyz,lightColor, lightIntensity, F0, metalness, roughness);
        directIllumination += res.color;
      }
    }

  vec3 combined = indirectIllumination + directIllumination;

  vec3 currentRayCount =  vec3(uni.raytracingSettings.currentRayCount);
  vec3 rayBudget =  vec3(uni.raytracingSettings.rayBudget);
  vec3 invNext = rayBudget / (currentRayCount + rayBudget);

  // new progressive average in one line
  vec3 accumulatedColor = currentColor.rgb
                        + (combined - currentColor.rgb) * invNext;

  // gamma‑correct and store
  vec3 gammaCorrectedColor = LINEARtoSRGB(accumulatedColor);
  vec3 dotp = vec3(dot(N, L));

  vec3 diff = emission.xyz - worldPos.xyz;

  imageStore(image,
            ivec2(gl_LaunchIDEXT.xy),
            vec4(gammaCorrectedColor, 1.0));
  // imageStore(image,
  //           ivec2(gl_LaunchIDEXT.xy),
  //           vec4(worldPos, 1.0));
}
