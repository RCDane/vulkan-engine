

#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_scalar_block_layout : require


#include "../common/host_device.h"
#include "../common/PBR_functions.glsl"
#include "../common/util.glsl"

// clang-format off
layout(location = 0) rayPayloadEXT hitPayload prd;
layout(location = 1) rayPayloadEXT bool isShadowed;

layout(set = 0, binding = eTlas) uniform accelerationStructureEXT topLevelAS;
layout(set = 0, binding = eOutImage, rgba16f) uniform image2D image;
layout(set = 1, binding = 0) uniform _GlobalUniforms { GlobalUniforms uni; };
layout(set = 1, binding = 5, scalar) buffer LightSources { LightSource lights[]; };
layout(set = 2, binding = 0, rgba16f) uniform image2D albedo; 
layout(set = 2, binding = 1, rgba16f) uniform image2D normal; 
layout(set = 2, binding = 2, rgba16f) uniform image2D material;
layout(set = 2, binding = 3, rgba32f) uniform image2D emission; 
layout(set = 2, binding = 4, r32f) uniform image2D depth;
layout(set = 2, binding = 5, rgba32f) uniform image2D colorHistory;

layout(push_constant) uniform _PushConstantRay { PushConstantRay pcRay; };
// clang-format on

float zNear = 0.1;
float zFar = 1000.0;

float LinearizeDepth(float depth) {
    // depth ∈ [0,1], where 1.0 → zNear and 0.0 → zFar
    return zNear * zFar / (zFar + depth * (zNear - zFar));
}

vec3 reconstructWorldPosition(
    double rawDepth,        // non‑linear depth sample ∈ [0,1], near→1, far→0
    vec2 fragCoord,        // pixel coords (e.g., gl_FragCoord.xy + 0.5)
    vec2 viewportSize,     // render target dims
    mat4 invProj,          // inverse projection matrix
    mat4 invView           // inverse view (camera) matrix
) {
    // 1) Compute NDC X/Y ∈ [−1,1]
    dvec2 ndc;
    ndc.x = double(fragCoord.x) / double(viewportSize.x) * 2.0 - 1.0;
    ndc.y = double(fragCoord.y) / double(viewportSize.y) * 2.0 - 1.0;
    // (You can flip Y here if your proj already flipped it) 
    // 2) Use rawDepth as NDC Z (Vulkan reversed‑Z, already in [0,1])
    double ndcZ = rawDepth;

    // 3) Form clip‑space position (homogeneous)
    dvec4 clipPos = dvec4(ndc, ndcZ, 1.0);

    // 4) Unproject to view (eye) space
    dvec4 viewPos = invProj * clipPos;
    viewPos /= viewPos.w;

    // 5) Transform into world space
    dvec4 worldPosH = invView * viewPos;
    return vec3(worldPosH.xyz);
}

struct LightSample {
  vec3 color;
  vec3 direction;
  float intensity;
  float distance;
  vec3 attenuation;
  float pdf;
};


// Sample sphere 
vec3 sampleSphere(vec3 center, float radius, inout uint seed)
{
  vec3 position = vec3(0.0);
  float u = rnd(seed);
  float v = rnd(seed);
  float theta = 2.0 * PI * u;
  float phi = acos(1.0 - 2.0 * v);
  position.x = radius * sin(phi) * cos(theta) + center.x;
  position.y = radius * sin(phi) * sin(theta) + center.y;
  position.z = radius * cos(phi) + center.z;
  return position;  
}

const float INF_DISTANCE = 1e20;

LightSample sampleLightsPdf(vec3 hitPoint, inout uint seed) {
    // 1) Pick one light uniformly
    uint i = randRange(seed, 0, uni.raytracingSettings.lightCount - 1);
    LightSource Ls = lights[i];
    float selectPdf = 1.0 / float(uni.raytracingSettings.lightCount);  // P(l)

    LightSample ls;
    ls.pdf = selectPdf;         // pdf of the light source
    ls.color = Ls.color;           // base color of the light
    ls.intensity = Ls.intensity;   // scalar intensity

    if (Ls.type == 0) {

        vec3 samplePos = sampleSphere(Ls.position, Ls.radius, seed);

        vec3 toLight   = samplePos - hitPoint;
        float dist     = length(toLight);
        vec3 dir       = normalize(toLight);

        float area     = 4.0 * PI * Ls.radius * Ls.radius;
        float areaPdf  = 1.0 / area;

        ls.pdf = ls.pdf * areaPdf;

        ls.intensity = ls.intensity / (area*PI); // scale intensity by area pdf
        ls.attenuation =  vec3(1)/(dist * dist);

        ls.direction = dir;
        ls.distance  = dist;
    } else {
        vec3 dir = -normalize(Ls.direction);

        // ls.pdf         = selectPdf;      // no changes to the pdf needed
        
        ls.direction   = Ls.direction;
        ls.distance    = INF_DISTANCE;   // treat as infinitely distant
        ls.attenuation = vec3(1.0);
    }

    return ls;
}


void main()
{
  const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
  const vec2 inUV        = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
  vec2       d           = inUV * 2.0 - 1.0;
  vec4 origin    = uni.viewInverse * vec4(0, 0, 0, 1);

  vec4 target    = uni.projInverse * vec4(d.x, d.y, 1, 1);
  vec4 direction = uni.viewInverse * vec4(normalize(target.xyz), 0);

  vec4 currentColor = imageLoad(colorHistory, ivec2(gl_LaunchIDEXT.xy));
  double currentDepth = imageLoad(depth, ivec2(gl_LaunchIDEXT.xy)).r;
  if (currentDepth == 0.0) {
    return; // If there is no depth, then nothing has been rendered here.
  }
  vec3 N =        imageLoad(normal, ivec2(gl_LaunchIDEXT.xy)).xyz;
  vec4 material = imageLoad(material, ivec2(gl_LaunchIDEXT.xy));
  vec4 albedoColor = imageLoad(albedo, ivec2(gl_LaunchIDEXT.xy));
  vec4 emission =        imageLoad(emission, ivec2(gl_LaunchIDEXT.xy));

  vec2 vpSize      = vec2(gl_LaunchSizeEXT.xy);  
  vec3 worldPos = reconstructWorldPosition(
    currentDepth, 
    pixelCenter, 
    vpSize, 
    uni.projInverse, 
    uni.viewInverse);


  float roughness = material.r;
  float metalness = material.g;
  prd.seed = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, int(uni.raytracingSettings.seed));;



  direction = -direction;
  vec3 V = normalize(origin.xyz- worldPos);
  LightSample l_Sample = sampleLightsPdf(worldPos, prd.seed);








  int rayDepth = 0;
	prd.depth = 0;
	vec3 tangent, bitangent;
  float e = 1e-3;

  prd.rayOrigin = worldPos;
  prd.rayDir = -direction.xyz;
  prd.normal = N;
  prd.attenuation = vec3(1.0);
  vec3 F0 = mix(vec3(0.04), albedoColor.xyz, metalness);
	vec3 rayOrigin = prd.rayOrigin + V*e;
	vec3 hitNormal = prd.normal;
  createCoordinateSystem(hitNormal, tangent, bitangent);

	vec3 rayDirection = samplingHemisphere(prd.seed, tangent, bitangent, hitNormal);
  vec3 firstDirection = rayDirection;
  vec3 indirectIllumination = vec3(0);
  for (;;){

		float tMin   = e;
		float tMax   = 10000000.0;
		vec3  rayDir = rayDirection;
		uint  flags  = gl_RayFlagsNoneEXT;
		prd.depth += 1;
		prd.rayDir = rayDir;
    prd.hitValue = vec3(0);
		traceRayEXT(topLevelAS,  // acceleration structure
						flags,       // rayFlags
						0xFF,        // cullMask
						0,           // sbtRecordOffset
						0,           // sbtRecordStride
						0,           // missIndex
						rayOrigin,      // ray origin
						tMin,        // ray min range
						rayDirection,      // ray direction
						tMax,        // ray max range
						0            // payload is payload
		);

  	float cosNL    = max(dot(N, rayDirection), 0.0);
    float hemiPdf  = cosNL / PI;
    float invPdf   = PI / max(cosNL, 1e-6);


    PBR_result result = CalculatePBRResult(
      N,V,
      rayDirection, albedoColor.xyz, 
      prd.hitValue, 1.0f, 
      F0, metalness, 
      roughness);
    


		indirectIllumination += result.color * prd.attenuation;
    if(prd.depth > 0 || prd.done == 1)
      break;
    rayOrigin = prd.rayOrigin + V*e;
    hitNormal = prd.normal;
    createCoordinateSystem(hitNormal, tangent, bitangent);

    rayDirection = samplingHemisphere(prd.seed, tangent, bitangent, hitNormal);
  }


  // vec3 finalIndirect = res.color;


  // Next event estimation for direct lighting
  isShadowed   = true; 
  vec3 directIllumination = vec3(0.0);

  vec3 L = normalize(l_Sample.direction);

    if(dot(N, l_Sample.direction) > 0)
    {
      float tMin   = 0.01;
      float tMax   = l_Sample.distance;
      vec3  rayOrigin = worldPos;
      vec3  rayDir = L;
      uint  flags  = gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT | gl_RayFlagsSkipClosestHitShaderEXT;
      traceRayEXT(topLevelAS,  // acceleration structure
            flags,       // rayFlags
            0xFF,        // cullMask
            0,           // sbtRecordOffsetw
            0,           // sbtRecordStride
            1,           // missIndex
            rayOrigin,      // ray origin
            tMin,        // ray min range
            rayDir,      // ray direction
            tMax,        // ray max range
            1            // payload is isShadowed
      );

      if (!isShadowed){
        PBR_result res =  CalculatePBRResult(N,V,L,albedoColor.xyz,l_Sample.color, l_Sample.intensity, F0, metalness, roughness);
        directIllumination += (res.color * l_Sample.attenuation) / l_Sample.pdf;

      }
    }

  vec3 combined = directIllumination + indirectIllumination;

  vec3 currentRayCount =  vec3(uni.raytracingSettings.currentRayCount);
  vec3 rayBudget =  vec3(uni.raytracingSettings.rayBudget);
  vec3 invNext = rayBudget / (currentRayCount + rayBudget);

  // new progressive average in one line
  vec3 accumulatedColor = currentColor.rgb
                        + (combined - currentColor.rgb) * invNext;

  // gamma‑correct and store

  vec3 dotp = vec3(dot(N, l_Sample.direction));

  imageStore(colorHistory,
            ivec2(gl_LaunchIDEXT.xy),
            vec4(accumulatedColor, 1.0));

}
