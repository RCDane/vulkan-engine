#version 450

#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_buffer_reference : require
#include "../common/PBR_functions.glsl"

#include "../input_structures.glsl"
#include "../common/host_device.h"
#include "../common/util.glsl"

// From Falcor
    // Texture2D gMotion;
    // Texture2D gPositionNormalFwidth;
    // Texture2D gColor;
    // Texture2D gAlbedo;
    // Texture2D gEmission;
    // Texture2D gPrevIllum;
    // Texture2D gPrevMoments;
    // Texture2D gLinearZAndNormal;
    // Texture2D gPrevLinearZAndNormal;
    // Texture2D gPrevHistoryLength;

// Motion not needed
layout(set = 0, binding = 0, rgba32f) uniform image2D packedNormalDepth;
layout(set = 0, binding = 1, rgba32f) uniform image2D color;
layout(set = 0, binding = 2, rgba16f) uniform image2D albedo;
// rename to avoid shadowing below
layout(set = 0, binding = 3, rgba16f) uniform image2D prevIlluminationImage;
layout(set = 0, binding = 4, rgba32f) uniform image2D prevPackedNormalDepth;
layout(set = 0, binding = 5, r8ui) uniform uimage2D prevHistoryLengthImage;
layout(set = 0, binding = 6, rg16f) uniform image2D prevMoments;
layout(set = 0, binding = 7, rgba16f) uniform image2D illumination;
layout(set = 0, binding = 8, rgba16f) uniform image2D metalRoughnessTexture;
layout(set = 0, binding = 9, rgba16f) uniform image2D prevMetalRoughnessTexture;



// new depth reprojection uniforms (after binding=7)
layout(push_constant ) uniform PushConstant { PushConstantReproj pc; } PC;

const float reprojEps = 1e-4;

float gAlpha = 0.1;
float gMomentsAlpha = 0.2;
  

bool isReprjValid(
    ivec2 coord,
    double Z,
    double Zprev,
    double fwidthZ,
    vec3 normal,
    vec3 normalPrev, 
    float fwidthNormal,
    vec2 metalRoughness,
    vec2 metalRoughnessPrev
) {
    ivec2 imageDim = PC.pc.imageSize;

    // 1) check whether reprojected pixel is inside the screen (with 1px border)
    if (any(lessThan(coord, ivec2(0))) || any(greaterThanEqual(coord, imageDim))) 
    {
        return false;
    }
    

    // 2) check if deviation of depths is acceptable
    if ( abs(Zprev - Z) / (fwidthZ + 1e-2) > 0.01 )
        return false;

    // 3) normals compatibility
    if ( dot(normal, normalPrev) < 0.95 )
        return false;

    vec2 diff = abs(metalRoughness-metalRoughnessPrev);
    float MRdiff = 0.2;
    if (diff.x > MRdiff || diff.y > MRdiff ){
        return false;
    }

    return true;
}
vec3 demodulate(vec3 c, vec3 albedo)
{
    return c / max(albedo, vec3(0.001, 0.001, 0.001)); 
}

float computeWeightVariance(
    float depthCenter,
    float depthP,
    float phiDepth,
    vec3 normalCenter,
    vec3 normalP,
    float phiNormal
)
{


    const float weightNormal = pow(clamp(dot(normalCenter, normalP), 0.0, 1.0), phiNormal);
    
    const float weightZ = (phiDepth == 0) ? 0.0f : abs(depthCenter - depthP) / phiDepth;

    const float weightIllum = exp(0.0 - max(weightZ, 0.0) ) * weightNormal;


    return weightIllum;
}

vec3 calculateIlluminationExpectation(ivec2 ipos, vec3 illumCenter){
    float sumWIllumination = 0.0;
        vec3 sumIllumination = vec3(0.0, 0.0, 0.0);

        const vec4 normalFZwidth = imageLoad(prevPackedNormalDepth, ipos);
        const vec2 MRCenter = imageLoad(prevMetalRoughnessTexture, ipos).xy;

        float depth = float(LinearizeDepth(normalFZwidth.x));
        float zWidth = normalFZwidth.y;
        float phiMR = 10.0; 
        const float gPhiColor = 10.0;
        const vec3 normalCenter = oct_to_ndir_unorm(normalFZwidth.zw);
        const float phiDepth = float(max(LinearizeDepth(depth), 1e-8)*3.0);

        const float gPhiNormal = 128.0;
        const int radius = 1;


        vec3 sqIllumDifference = vec3(0.0);
        int count = 0;
        for (int yy = -radius; yy <= radius; yy++)
        {
            for (int xx = -radius; xx <= radius; xx++)
            {
                const ivec2 p = ipos + ivec2(xx, yy);
                const bool inside = isInsideScreen(p, PC.pc.imageSize);
                const bool samePixel = (xx == 0 && yy == 0);
                const float kernel = 1.0;

                if (inside)
                {
                    vec4 illumP = imageLoad(prevIlluminationImage, p);
                    const vec2 MRP = imageLoad(prevMetalRoughnessTexture, p).xy;

                    const float lIlluminationP = luminance(illumP.rgb);
                    const vec4 packedNormal = imageLoad(prevPackedNormalDepth, p);
                    const float zP = float(LinearizeDepth(packedNormal.x));
                    const vec3 nP = oct_to_ndir_unorm(packedNormal.zw);

                    const float w = computeWeight(
                        depth,
                        zP,
                        phiDepth * length(vec2(xx, yy)),
                        normalCenter,
                        nP,
                        gPhiNormal,
                        luminance(illumCenter),
                        lIlluminationP,
                        gPhiColor,
                        MRCenter,
                        MRP,
                        phiMR
                    );
                    float l = luminance(illumP.rgb);
                    sqIllumDifference += ((illumCenter-l)*(illumCenter-l)) * w;

                    sumWIllumination += w;
                    count++;
                }
            } 
        }

    sqIllumDifference = sqIllumDifference / sumWIllumination;
    return sqIllumDifference ;
}
vec3 computeSigmaY2(ivec2 ipos) {
    const int radius = 2;
    int count = 0;
    vec3 sumY  = vec3(0.0);
    vec3 sumY2 = vec3(0.0);

    // Loop over 3×3 neighbourhood
    for (int yy = -radius; yy <= radius; ++yy) {
        for (int xx = -radius; xx <= radius; ++xx) {
            ivec2 p = ipos + ivec2(xx, yy);
            // bounds‐check
            if (any(lessThan(p, ivec2(0))) || any(greaterThanEqual(p, PC.pc.imageSize))) {
                continue;
            }

            // fetch current-frame color + albedo → demodulate to get Y
            vec3  c    = imageLoad(color,  p).rgb;
            vec3  alb  = imageLoad(albedo, p).rgb;
            vec3  Y    = demodulate(c, alb);

            sumY  += Y;
            sumY2 += Y * Y;
            count++;
        }
    }

    // if nothing valid (shouldn’t really happen), avoid div0
    float invN = (count > 0) ? (1.0 / float(count)) : 0.0;

    vec3 E_Y   = sumY  * invN;
    vec3 E_Y2  = sumY2 * invN;

    // σ² = E[Y²] – (E[Y])², clamp ≥0
    return max(vec3(0.0), E_Y2 - E_Y * E_Y);
}


vec2 calculateMoments(ivec2 ipos){
        float sumWIllumination = 0.0;
        vec3 sumIllumination = vec3(0.0, 0.0, 0.0);
        vec2 sumMoments = vec2(0.0, 0.0);

        vec4 albedoColor = imageLoad(albedo, ipos);
        vec4 imageColor = imageLoad(color, ipos);
            
        vec3 illumCenter = demodulate(imageColor.xyz, albedoColor.xyz);

        const vec4 normalFZwidth = imageLoad(packedNormalDepth, ipos);
        const vec2 MRCenter = imageLoad(metalRoughnessTexture, ipos).xy;

        float depth = float(LinearizeDepth(normalFZwidth.x));
        float zWidth = normalFZwidth.y;
        float phiMR = 5.0; 
        const float gPhiColor = 10.0;
        const vec3 normalCenter = oct_to_ndir_unorm(normalFZwidth.zw);
        const float phiDepth = float(max(LinearizeDepth(depth), 1e-8)*3.0);
        const float gPhiNormal = 128.0;
        const int radius = 1;

        float y2 = 0.0;
        float y1 = 0.0;
        int count = 0;
        for (int yy = -radius; yy <= radius; yy++)
        {
            for (int xx = -radius; xx <= radius; xx++)
            {
                const ivec2 p = ipos + ivec2(xx, yy);
                const bool inside = isInsideScreen(p, PC.pc.imageSize);
                const bool samePixel = (xx == 0 && yy == 0);
                const float kernel = 1.0;

                if (inside && !samePixel)
                {
                    vec4 albedoColor = imageLoad(albedo, p);
                    vec4 imageColor = imageLoad(color, p);
            
                    vec3 illumP = demodulate(imageColor.xyz, albedoColor.xyz);
                    const vec2 MRP = imageLoad(prevMetalRoughnessTexture, p).xy;

                    vec2 momentsP;
                    momentsP.r = luminance(illumP);
                    momentsP.g = momentsP.r * momentsP.r;




                    const float lIlluminationP = luminance(illumP.rgb);
                    const vec4 packedNormal = imageLoad(packedNormalDepth, p);
                    const float zP = float(LinearizeDepth(packedNormal.x));
                    const vec3 nP = oct_to_ndir_unorm(packedNormal.zw);

                    const float w = computeWeight(
                        depth,
                        zP,
                        phiDepth * length(vec2(xx, yy)),
                        normalCenter,
                        nP,
                        gPhiNormal,
                        luminance(illumCenter),
                        lIlluminationP,
                        gPhiColor,
                        MRCenter,
                        MRP,
                        phiMR
                    );
                    y1 += momentsP.r * w;
                    y2 += momentsP.g * w;

                    sumWIllumination += w;
                    // sumIllumination += illumP * w;
                    count++;
                }
            } 
        }

        sumWIllumination = max(sumWIllumination, 1e-6f);

        sumIllumination /= sumWIllumination;
        y1 = y1 / sumWIllumination;
        y2 = y2 / sumWIllumination;
        y1 = y1*y1;

        float variance = max(0.f, y2 - y1);

        sumWIllumination = max(sumWIllumination, 1e-6f);

        sumIllumination /= sumWIllumination;

        // compute variance using the first and second moments

    return vec2(y1, y2);

}


vec3 calculateAverageIlluminance(ivec2 ipos){
    
    int radius = 1; // updated radius to 2
    vec3 illumSum = vec3(0);

    const float kernel[3][3] = {
        { 1.0/4.0,    1.0/8.0,    1.0/16.0 },
        { 1.0/8.0,    1.0/16.0,   1.0/32.0 },
        { 1.0/16.0,   1.0/32.0,   1.0/64.0 }
    };
    const vec4 nd = imageLoad(packedNormalDepth, ipos);
    const float z = float(LinearizeDepth(nd.x));

    const vec3 n = oct_to_ndir_unorm(nd.zw);
    float weightSum = 1.0;

    for (int yy = -radius; yy <= radius; yy++){
        for  (int xx = -radius; xx <= radius; xx++){
            const ivec2 p = ipos + ivec2(xx, yy);
            const bool inside = isInsideScreen(p,  PC.pc.imageSize);

        if (inside && (xx != 0 || yy != 0)) 
        {

            vec4 albedoColor = imageLoad(albedo, p);
            vec4 imageColor = imageLoad(color, p);
            
            const float k = kernel[abs(xx)][abs(yy)];
            vec3 illum = demodulate(imageColor.xyz, albedoColor.xyz);
            const vec4 np = imageLoad(packedNormalDepth, p);
            const float zP = float(LinearizeDepth(np.x));

            const vec3 nP = oct_to_ndir_unorm(np.zw);
            float weight = computeWeightVariance(
                z,
                zP,
                10.0,
                n,
                nP,
                128.0
            );

            illumSum += illum  * k;
            weightSum += weight;
        }

        }
    }

    return illumSum / weightSum;
}

float computeMSD(ivec2 ipos, vec3 X) {
    const int radius = 2;
    int    count = 0;
    float  sum   = 0.0;
    // luminance weights for Y → scalar metric
    const vec3  Lw = vec3(0.2126, 0.7152, 0.0722);

    for (int yy = -radius; yy <= radius; ++yy) {
        for (int xx = -radius; xx <= radius; ++xx) {
            ivec2 p = ipos + ivec2(xx, yy);
            // bounds‐check
            if (any(lessThan(p, ivec2(0))) ||
                any(greaterThanEqual(p, PC.pc.imageSize))) {
                continue;
            }

            // fetch current‐frame illumination Y
            vec3  c   = imageLoad(color,  p).rgb;
            vec3  alb = imageLoad(albedo, p).rgb;
            vec3  Y   = demodulate(c, alb);

            // accumulate (Y - X)^2 in luminance
            vec3  d2  = (Y - X) * (Y - X);
            sum      += dot(d2, Lw);

            count++;
        }
    }

    return (count > 0) ? (sum / float(count)) : 0.0;
}


bool loadPrevData(
    vec2 posH,
    ivec2 ipos,
    vec3 newIllum,
    out vec4 prevIllum,
    out vec2 pMoments,
    out uint historyLength,
    out float alpha
) {
    vec2 imageDim = PC.pc.imageSize;


    vec4 pNormalDepth = imageLoad(packedNormalDepth, ivec2(ipos));
    double linearDepth = LinearizeDepth(double(pNormalDepth.x));

    vec3 currentNormal = oct_to_ndir_unorm(pNormalDepth.zw);



    float normalFwidth = 0;
    double zWidth = pNormalDepth.y;

    double depth = invLinearizeDepth(linearDepth);
    dvec3 worldPos = reconstructWorldPosition(
        pNormalDepth.x, ipos, imageDim,
        PC.pc.projInverse, PC.pc.viewInverse
    );

    vec4 prevClip = PC.pc.oldViewProj * vec4(worldPos, 1.0); 
    vec3 prevNDC  = prevClip.xyz / prevClip.w; 
    vec2 prevUV   = prevNDC.xy * 0.5 + 0.5;
    vec2 posPrev  = prevUV * imageDim + (vec2(1.0) / imageDim);
    ivec2 iposPrev = ivec2(floor(posPrev));  // base for bilinear taps



    vec3 MRTex = imageLoad(metalRoughnessTexture, ipos).xyz;
    vec2 metalRoughness = MRTex.xy;
    int objID = int(MRTex.z);

    prevIllum   = vec4(0.0);
    pMoments = vec2(0.0);

    // bilinear taps
    ivec2 offsets[4] = ivec2[4](
        ivec2(0,0), ivec2(1,0),
        ivec2(0,1), ivec2(1,1)
    ); 
    bool v[4];
    bool valid = false;

    // 1) test validity at each tap
    for (int i = 0; i < 4; ++i) {
        ivec2 loc = iposPrev + offsets[i];
        if (any(lessThan(loc, ivec2(0))) || any(greaterThanEqual(loc, imageDim))) { 
            v[i] = false;
        } else { 
            vec3 prevMetalRoughness = imageLoad(prevMetalRoughnessTexture, loc).xyz;
            if (int(prevMetalRoughness.z) != objID)
            {
                v[i] = false;
            }
            else {
                vec4 PND = imageLoad(prevPackedNormalDepth, loc);

                double prevD = LinearizeDepth(PND.r);
                vec3 nP   = normalize(oct_to_ndir_unorm(PND.zw));
                v[i] = isReprjValid(loc, linearDepth, prevD, zWidth, currentNormal, nP, normalFwidth, metalRoughness, prevMetalRoughness.xy);
            }

        }
        valid = valid || v[i];
    }

    // // 2) if any valid, do bilinear interp
    if (valid) {
        float fx = fract(posPrev.x), fy = fract(posPrev.y);
        float w[4] = float[4](
            (1.-fx)*(1.-fy),
             fx *(1.-fy),
            (1.-fx)* fy,
             fx * fy
        );
        float sumw = 0.0;
        for (int i = 0; i < 4; ++i) {
            ivec2 loc = iposPrev + offsets[i];
            if (v[i]) {
                prevIllum   += w[i] * imageLoad(prevIlluminationImage, loc);
                pMoments += w[i] * imageLoad(prevMoments, loc).xy ;
                sumw        += w[i];
            }
        }
        if (sumw < 1.0) {
            prevIllum   = vec4(0.0);
            pMoments = vec2(0.0);
            valid       = false;
        } else {
            prevIllum   /= sumw;
            pMoments /= sumw;
        }

    }

    // 3) fallback cross‐bilateral if still invalid
    if (!valid) {
        float nValid = 0.0;
        for (int yy = -1; yy <= 1; ++yy) {
            for (int xx = -1; xx <= 1; ++xx) {
                ivec2 p = iposPrev + ivec2(xx, yy);
                if (any(lessThan(p, ivec2(0))) || any(greaterThanEqual(p, imageDim))) continue;
                
                vec3 prevMetalRoughness = imageLoad(prevMetalRoughnessTexture, p).xyz;
                if (int(prevMetalRoughness.z) == objID){
                    vec4 PND = imageLoad(prevPackedNormalDepth, p);

                    double prevD = LinearizeDepth(PND.r);

                    vec3 nP   = oct_to_ndir_unorm(PND.zw);


                    if (isReprjValid(p, linearDepth, prevD, zWidth, currentNormal, nP, normalFwidth,metalRoughness, prevMetalRoughness.xy)) {
                        prevIllum   += imageLoad(prevIlluminationImage, p);
                        pMoments += imageLoad(prevMoments, p).xy;
                        nValid      += 1.0;
                    }
                }

            }
        }
        if (nValid > 0.0) {
            prevIllum   /= nValid;
            pMoments /= nValid;
            valid        = true;
        }
    }

    if (valid){
        // Luminance weights for perceptual averaging
        const vec3 luminanceWeights = vec3(0.2126, 0.7152, 0.0722);

        // Variance estimates
        vec3 estimatedCurrentIllum = calculateIlluminationExpectation(ipos, prevIllum.rgb); // σ²_Y

        vec3 illumVariance = computeSigmaY2(ipos);
        float sigmaX2 = prevIllum.a;               // σ²_X (stored in RGB)

        float msdXY = computeMSD(ipos, prevIllum.rgb); // MSD(X, Y)
        // Convert variances to scalar using luminance weighting
        vec3 sigmaY2 = estimatedCurrentIllum;
        // float sigmaX2 = dot(prevVariance, luminanceWeights);

        const vec3 Lw  = vec3(0.2126, 0.7152, 0.0722);
        float num      = dot(sigmaY2, Lw);
        // Estimate bias^2 as (X - Y)^2 using previous and current radiance estimates
        vec3 currentIllum = newIllum; // You may already have this
        vec3 previousIllum = prevIllum.xyz; // From history buffer
        vec3 illumDiff = estimatedCurrentIllum - previousIllum;
        float bias2 = dot(illumDiff * illumDiff, luminanceWeights);

        // Final alpha (blending factor)
        float alpha3 = 1.0 - ((luminance(illumVariance)) / luminance(estimatedCurrentIllum));
        alpha          = clamp(1.0 - num/msdXY, 0.0, 1.0);
        imageStore(color, ipos, vec4(estimatedCurrentIllum, alpha));
    }
    else {
        alpha = 1.0;
    }




    // 4) write out history length if valid
    if (valid) {
        historyLength = imageLoad(prevHistoryLengthImage, iposPrev).x;
    } else {
        prevIllum     = vec4(0.0);
        pMoments   = vec2(0.0);
        historyLength = 0;
    }

    return valid;
}








// helper: bounds‐check uv in [0,size)
bool CheckUv(vec2 uv, vec2 size){
    return all(greaterThanEqual(uv, vec2(0.0))) && all(lessThan(uv, size));
}
layout (local_size_x = 16, local_size_y = 16) in;




void main(){
    const ivec2 coord = ivec2(gl_GlobalInvocationID.xy);

    const vec2 pixelCenter = vec2(gl_GlobalInvocationID.xy) + vec2(0.5);
    const vec2 inUV        = pixelCenter / PC.pc.imageSize;

    vec4 albedoColor = imageLoad(albedo, coord);
    vec4 imageColor = imageLoad(color, coord);

    vec3 illum = demodulate(imageColor.xyz, albedoColor.xyz);

    if (any(isnan(illum))){
        illum = vec3(0,0,0);
    }

    // reprojection temp storage
    vec4 prevIllum = vec4(0.0);
    uint historyLength = 0;
    vec2 pMoments;
    float alpha = 0.0;
    bool success = loadPrevData(pixelCenter, coord, illum,prevIllum, pMoments, historyLength, alpha);

    // imageStore(color, coord, success ? vec4(imageColor) : vec4(1.0,0.0,1.0,1.0));

    historyLength = min(32, success ? historyLength + 1 : 1);


    // const float alpha = success ? max(gAlpha, 1.0 / historyLength) : 1.0;
    const float alphaMoments = success ? max(gMomentsAlpha, 1.0 / historyLength) : 1.0;

    // compute first two moments of luminance
    vec2 moments;
    moments.r = luminance(illum);
    moments.g = moments.r * moments.r;

    vec2 pm = moments;

    // temporal integration of the moments
    moments = mix(pMoments, moments, alphaMoments);

    float variance = max(0.f, moments.g - moments.r * moments.r);

    vec3 blendedIllum = mix(prevIllum.rgb, illum, alpha);

    imageStore(prevMoments,coord, vec4(moments, 1.0,1.0));
    imageStore(prevHistoryLengthImage,coord, ivec4(historyLength, 0,0,0));
    // imageStore(illumination,coord, vec4(illum, variance));
    imageStore(illumination,         coord, vec4(blendedIllum,  variance));
}